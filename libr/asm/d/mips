add=adds two registers, trap on overflow
addi=add sign-extended constants (or copy one register to another: addi $1, $2, 0), trap on overflow
addiu=add sign-extended constants (or copy one register to another: addi $1, $2, 0)
addu=adds two registers
and=bitwise and
andi=bitwise and, leftmost 16 bits are padded with 0s
beq=beq $s,$t,C, goes to the instruction at the specified address if two registers are equal.
blez=branch if the register is less than or equal to zero.
bneq=goes to the instruction at the specified address if two registers are not equal.
cache=perform cache operation.
div=divides two registers and puts the 32-bit integer result in LO and the remainder in HI.
divu=divides two registers and puts the 32-bit integer result in LO and the remainder in HI.
j=unconditionally jumps to the instruction at the specified address
jal=used to call a subroutine, $31 holds the return address; returning from a subroutine is done by: jr $31. Return address is PC + 8, not PC + 4 due to the use of a branch delay slot which forces the instruction after the jump to be executed
jr=jumps to the address contained in the specified register
jraddiusp=increment stackpointer and jump to ra register
li=load immediate (pseudoinstruction)
lb=lb $t,C($s), loads the byte stored from: MEM[$s+C], sign is extended to width of register
lh=lh $t,C($s), loads the halfword stored from: MEM[$s+C] and the following byte, sign is extended to width of register.
lhu=lhu $t,C($s), loads the halfword stored from: MEM[$s+C] and the following byte.
lui=loads a 16-bit immediate operand into the upper 16-bits of the register specified.
lw=lw $t,C($s), loads the word stored from: MEM[$s+C] and the following 3 bytes.
mfcZ=moves a 4 byte value from Coprocessor Z Control register to a general purpose register. Sign extension.
mfhi=moves a value from HI to a register
mflo=moves a value from LO to a register
move=moves a register value into another register (pseudoinstruction).
movn=conditional move.
movz=conditional move.
mtcZ=moves a 4 byte value from a general purpose register to a Coprocessor Z Control register. Sign extension.
mult=int HI, int LO = (64-bit) $s * $t, trap on overflow
multu=int HI, int LO = (64-bit) $s * $t
nop=no operation
nor=bitwise nor
or=bitwise or
ori=bitwise or, leftmost 16 bits are padded with 0s
sb=sb $t,C($s), stores the least-significant 8-bit of a register (a byte) into: MEM[$s+C].
sc=store a word to memory.
sh=sh $t,C($s), stores the least-significant 16-bit of a register (a halfword) into: MEM[$s+C].
sll=sll $d,$t,shamt, shifts shamt number of bits to the left (multiply but 2^n)
sllv=sllv $d,$t,$s, shifts $s number of bits to the left 
slt=tests if one register is less than another.
slti=tests if one register is less than a constant.
sltu=tests if one register is less than an unsigned constant.
sra=sda $d,$t,shamt, shifts shamt number of bits - the sign bit is shifted in
srav=srav $d,$t,$s, shifts $s number of bits - the sign bit is shifted in
srl=srl $d,$t,shamt, shifts shamt number of bits to the right - zeros are shifted in.
srlv=srlv $d,$t,$s, shifts $s number of bits to the right - zeros are shifted in
sub=subtracts two registers, trap on overflow
subu=subtracts two registers
sw=sw $t,C($s), stores a word into: MEM[$s+C] and the following 3 bytes.
xor=bitwise xor
xori=bitwise xor with a constant
